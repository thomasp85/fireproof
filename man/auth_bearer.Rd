% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auth_bearer.R
\name{auth_bearer}
\alias{auth_bearer}
\title{Bearer authentication plugin}
\usage{
auth_bearer(
  authenticator,
  user_info = NULL,
  realm = "private",
  allow_body_token = TRUE,
  allow_query_token = FALSE,
  name = "BearerAuth"
)
}
\arguments{
\item{authenticator}{A function that will be called with the arguments
\code{token}, \code{realm}, \code{request}, and \code{response} and returns \code{TRUE} if the token
is valid, and \code{FALSE} otherwise. If the function returns a character vector
it is considered to be authenticated and the return value will be understood
as scopes the user is granted.}

\item{user_info}{A function to extract user information from the
username. It is called with two arguments: \code{token} and \code{setter},
the first being the token used for the successful authentication, the
second being a function that must be called in the end with the relevant
information (see \code{\link[=user_info]{user_info()}}).}

\item{realm}{The realm this authentication corresponds to. Will be returned
to the client on a failed authentication attempt to inform them of the
credentials required, though most often these days it is kept from the user.}

\item{allow_body_token}{Should it be allowed to pass the token in the request
body as a query form type with the \code{access_token} name. Defaults to \code{TRUE}
but you can turn it off to force the client to use the \code{Authorization}
header.}

\item{allow_query_token}{Should it be allowed to pass the token in the query
string of the url with the \code{access_token} name. Default to \code{FALSE} due to
severe security implications but can be turned on if you have very
well-thought-out reasons to do so.
to the \code{authenticator} function.}

\item{name}{The name of the authentication}
}
\value{
An \link{AuthBearer} R6 object
}
\description{
Bearer authentication is a HTTP scheme powers most of the modern web
authentication as it is the foundation for OAuth 2.0 and OpenID. It is a
quite simple scheme that is based on the concept of tome and scope limited
bearer tokens. Whoever has a valid token gains access to the resources the
token unlocks. This prevents the leaking of passwords s well as make it easy
to rotate tokens etc. While the time-limited aspect of tokens means that an
attacker may only gain temporary access to a resource if they intercept a
token during transmission, it is still highly recommended to only transmit
tokens over HTTPS
}
\details{
This authenticator will use a user provided function to test a token. The
complexity of the test fully depends on the issuer of the token. At it's
simplest the token is opaque and the function test it against a database.
However, it is more common to use a JSON web token to encode various
information into the token itself that can help in determining scoped access
etc.

The authenticator should in general not test the scope of the token, but
rather write the scope of the token to the \code{auth_scope} field of the response
data store (\code{response$set_data("auth_scope", ...)}). The scope requirement of
the exact endpoint will then be tested automatically. Further, the
authenticator should write any additional user information that gets fetched
during the validation to relevant fields in the response data
}
\section{User information}{
\code{auth_bearer()} automatically adds \link[=user_info]{user information} after
authentication. By default it will set the \code{provider} field to \code{"local"}.
Further, it will set the \code{scopes} field to any scopes returned by the
\code{authenticator} function and the \code{token} field to a list with the following
elements:
\itemize{
\item \code{access_token}: The provided token
\item \code{token_type}: \code{"bearer"}
\item \code{scope} The scopes concatenated into a space separated string
}

This structure mimics the structure of the token information returned by
OAuth 2.0 and OpenID Connect services.
}

\examples{
# Create an authenticator of dubious quality
bearer <- auth_bearer(
  authenticator = function(token) {
    token == "abcd1234"
  },
  user_info = function(user, setter) {
    setter(
      name_given = "Thomas",
      name_middle = "Lin",
      name_family = "Pedersen"
    )
  },
  allow_body_token = FALSE
)

# Add it to a fireproof plugin
fp <- Fireproof$new()
fp$add_auth(bearer, "bearer_auth")

# Use it in an endpoint
fp$add_auth_handler("get", "/*", bearer_auth)

}
