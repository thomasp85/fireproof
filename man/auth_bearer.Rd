% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auth_bearer.R
\name{auth_bearer}
\alias{auth_bearer}
\title{Bearer authentication plugin}
\usage{
auth_bearer(
  authenticator,
  user_info = NULL,
  realm = "private",
  allow_body_token = TRUE,
  allow_query_token = FALSE,
  token_parser = identity,
  name = "BearerAuth"
)
}
\arguments{
\item{authenticator}{A function that will be called with the arguments
\code{token}, \code{realm}, \code{request}, and \code{response} and returns \code{TRUE} if the token
is valid, and \code{FALSE} otherwise. If the function returns a character vector
it is considered to be authenticated and the return value will be understood
as scopes the user is granted.}

\item{user_info}{A function to extract user information from the
username. It will be called with two arguments: \code{token} and \code{setter},
the first being the token used for the successful authentication, the
second being a function that must be called in the end with the relevant
information. The \code{setter} function takes the following arguments:
\code{id} (the identifier of the user), \code{display_name} (the name the user has
chosen as public name), \code{name_given} (the users real given name),
\code{name_middle} (the users middle name), \code{name_family} (the users family
name), \code{emails} (a vector of emails, potentially named with type, e.g.
"work", "home" etc), \code{photos} (a vector of urls for profile photos),
and \code{...} with additional named fields to add.}

\item{realm}{The realm this authentication corresponds to. Will be returned
to the client on a failed authentication attempt to inform them of the
credentials required, though most often these days it is kept from the user.}

\item{allow_body_token}{Should it be allowed to pass the token in the request
body as a query form type with the \code{access_token} name. Defaults to \code{TRUE}
but you can turn it off to force the client to use the \code{Authorization}
header.}

\item{allow_query_token}{Should it be allowed to pass the token in the query
string of the url with the \code{access_token} name. Default to \code{FALSE} due to
severe security implications but can be turned on if you have very
well-thought-out reasons to do so.}

\item{token_parser}{Optional function to parse the token before passing it on
to the \code{authenticator} function.}

\item{name}{The name of the authentication}
}
\value{
An \link{AuthBearer} R6 object
}
\description{
Bearer authentication is a HTTP scheme powers most of the modern web
authentication as it is the foundation for OAuth 2.0 and OpenID. It is a
quite simple scheme that is based on the concept of tome and scope limited
bearer tokens. Whoever has a valid token gains access to the resources the
token unlocks. This prevents the leaking of passwords s well as make it easy
to rotate tokens etc. While the time-limited aspect of tokens means that an
attacker may only gain temporary access to a resource if they intercept a
token during transmission, it is still highly recommended to only transmit
tokens over HTTPS
}
\details{
This authenticator will use a user provided function to test a token. The
complexity of the test fully depends on the issuer of the token. At it's
simplest the token is opaque and the function test it against a database.
However, it is more common to use a JSON web token to encode various
information into the token itself that can help in determining scoped access
etc.

The authenticator should in general not test the scope of the token, but
rather write the scope of the token to the \code{auth_scope} field of the response
data store (\code{response$set_data("auth_scope", ...)}). The scope requirement of
the exact endpoint will then be tested automatically. Further, the
authenticator should write any additional user information that gets fetched
during the validation to relevant fields in the response data
}
