% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/guard_bearer.R
\name{guard_bearer}
\alias{guard_bearer}
\title{Bearer authentication guard}
\usage{
guard_bearer(
  validate,
  user_info = NULL,
  realm = "private",
  allow_body_token = TRUE,
  allow_query_token = FALSE,
  name = "BearerAuth"
)
}
\arguments{
\item{validate}{A function that will be called with the arguments
\code{token}, \code{realm}, \code{request}, and \code{response} and returns \code{TRUE} if the token
is valid, and \code{FALSE} otherwise. If the function returns a character vector
it is considered to be authenticated and the return value will be understood
as scopes the user is granted.}

\item{user_info}{A function to extract user information from the
token. It is called with a single argument: \code{token} which is the token
used for the successful authentication. The function should return a new
\link[=new_user_info]{user_info} list.}

\item{realm}{The realm this authentication corresponds to. Will be returned
to the client on a failed authentication attempt to inform them of the
credentials required, though most often these days it is kept from the user.}

\item{allow_body_token}{Should it be allowed to pass the token in the request
body as a query form type with the \code{access_token} name. Defaults to \code{TRUE}
but you can turn it off to force the client to use the \code{Authorization}
header.}

\item{allow_query_token}{Should it be allowed to pass the token in the query
string of the url with the \code{access_token} name. Default to \code{FALSE} due to
severe security implications but can be turned on if you have very
well-thought-out reasons to do so.}

\item{name}{The name of the guard}
}
\value{
A \link{GuardBearer} R6 object
}
\description{
Bearer authentication is a HTTP scheme based on tokens. It is used
in a lot of places as it is often used for transmitting the tokens issued as
part of OAuth 2.0 and OpenID Connect authentication. It is a
quite simple scheme that is based on the concept of time- and scope-limited
bearer tokens. Whoever has a valid token gains access to the resources the
token unlocks. This prevents the leaking of passwords as well as makes it easy
to rotate tokens etc. While the time-limited aspect of tokens means that an
attacker may only gain temporary access to a resource if they intercept a
token during transmission, it is still highly recommended to only transmit
tokens over HTTPS
}
\details{
This \code{validate} function is provided by the user and is used to test the
provided token. The complexity of the test fully depends on the issuer of the
token. At it's simplest the token is opaque and the function test it against
a database. However, it is more common to use a JSON web token to encode various
information into the token itself that can help in determining scoped access
etc.

The \code{validate} function should not test the scope of the token, but
rather return a vector of scopes (which implicitly means that the token is
valid). The scope requirement of the exact endpoint will then be tested
automatically.
}
\section{User information}{
\code{guard_bearer()} automatically adds \link[=new_user_info]{user information} after
authentication. By default it will set the \code{provider} field to \code{"local"}.
Further, it will set the \code{scopes} field to any scopes returned by the
\code{validate} function and the \code{token} field to a list with the following
elements:
\itemize{
\item \code{access_token}: The provided token
\item \code{token_type}: \code{"bearer"}
\item \code{scope} The scopes concatenated into a space separated string
}

This structure mimics the structure of the token information returned by
OAuth 2.0 and OpenID Connect services.
}

\examples{
# Create a guard of dubious quality
bearer <- guard_bearer(
  validate = function(token) {
    token == "abcd1234"
  },
  user_info = function(user) {
    new_user_info(
      name_given = "Thomas",
      name_middle = "Lin",
      name_family = "Pedersen"
    )
  },
  allow_body_token = FALSE
)

# Add it to a fireproof plugin
fp <- Fireproof$new()
fp$add_guard(bearer, "bearer_auth")

# Use it in an endpoint
fp$add_auth("get", "/*", bearer_auth)

}
\references{
\href{https://datatracker.ietf.org/doc/html/rfc6750}{Bearer authentication RFC}
}
